# gif2_shrink.py
# Generates a smaller gif.h by resizing frames and limiting frame count.
from PIL import Image, ImageSequence
import sys

def rgb888_to_565(r,g,b):
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)

if len(sys.argv) < 4:
    print("Usage: python gif2_shrink.py <gif_path> <width> <height> [max_frames]")
    sys.exit(1)

path = sys.argv[1]
W = int(sys.argv[2]); H = int(sys.argv[3])
max_frames = int(sys.argv[4]) if len(sys.argv) > 4 else None

im = Image.open(path)

frames = []
delays = []
count = 0
for f in ImageSequence.Iterator(im):
    if max_frames is not None and count >= max_frames:
        break
    rgb = f.convert("RGB").resize((W, H))
    delays.append(int(f.info.get("duration", 100)))  # ms per frame
    pixels = list(rgb.getdata())
    frames.append([rgb888_to_565(*p) for p in pixels])
    count += 1

if len(frames) == 0:
    print("No frames extracted")
    sys.exit(1)

# Flatten all pixels and track offsets so we can address each frame
offsets = [0]
flat = []
for fr in frames:
    flat.extend(fr)
    offsets.append(len(flat))

out_path = "gif.h"
with open(out_path, "w") as out:
    out.write("// Auto-generated by gif2_shrink.py\n")
    out.write("#pragma once\n#include <stdint.h>\n\n")
    out.write(f"#define GIF_W {W}\n#define GIF_H {H}\n#define GIF_FRAMES {len(frames)}\n\n")
    out.write(f"static const uint32_t gif_offsets[GIF_FRAMES+1] = {{")
    out.write(",".join(map(str, offsets)))
    out.write("};\n")
    out.write(f"static const uint16_t gif_delays[GIF_FRAMES] = {{")
    out.write(",".join(map(str, delays)))
    out.write("};\n")
    out.write(f"static const uint16_t gif_pixels[{len(flat)}] = {{\n")
    line = 0
    for v in flat:
        out.write(f"0x{v:04X},")
        line += 1
        if line % 16 == 0: out.write("\n")
    out.write("\n};\n")

print(f"Wrote {out_path} ({len(frames)} frames, {W}x{H}, {len(flat)*2} bytes of pixel data)")
